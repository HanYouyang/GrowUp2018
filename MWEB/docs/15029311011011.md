# 链表——最小必要知识

### 2.3链表
顺序表的局限：

>1. 改变大小总是需要创建新表
>
>2. 增删时间平均移动一半的元素

**链表**是一组即存储数据又存储相互连接信息的节点集合。

链接存储还可以存储其他结构

#### 2.3.1单链表

**单链表**每各节点只包含指向其后继的指针。包含data域和指针域，终止节点指向NULL。

**2.6单链表的节点定义**

**自引用型**是指给出自身定义，而定义中的指针指向正在定义的本身的类型。

此处定义Link类是自定义的，能够继续用于其他类型的定义

单链表中的结点是一个独立的对象，故将其定义为一个独立的类，以便于复用。



通常可以加上指向终止节点的指针，tail指针，对尾部用append()添加有益。




**2.7单链表的类型定义**





还可以将head指针和tail指针结合形成**头结点**，避免空表和边界情况。作为表中的**虚节点**，这个结点的头被忽略，不被看坐表中的实际元素。


在链表中引用了与顺序表同样的对表最小长度的参数，此参数可以在实现中被忽略掉。


**2.8带有头结点的单链表构造函数与析构函数**

##### 1.链表的检索
按照下标和内容都是**循链比较**，又称**顺序访问**，无法随机读取。

按位置检索只要返回**指向该位置的指针**就可以了。



**2.9寻找链表的第i个结点**

##### 2.链表的插入和删除
只需要改变相应的next域就可以了。

插入包括三个步骤：
>1.创建一个新结点
>
>2.修改相关结点的链接信息
>
>3.维护原有的前驱后继关系

总共涉及两个节点：**新插入节点的前驱结点**和**新节点自身**。




**2.10插入单链表的第i个结点**
 
**2.11单链表的删除算法**

#### 2.3.2双链表
双链表是在每个节点中再增加一个指向前驱的指针。


**2.12双链表的结点定义和实现**
此时插入和删除稍微要麻烦一点，因为要兼顾两个指针。

#### 2.3.3循环链表
多个进程同时访问同一资源，用current指针移动激活进程。

单链表不增加任何开销，只需要尾结点指向头结点。


