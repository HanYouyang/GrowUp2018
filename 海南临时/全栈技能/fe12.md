第一节

前面的内容是浏览器编程，后面的是更高级的东西；
以后用webstorm编程；
95年用了10天制作这个语言，当初制作的是简单的东西，后面要求更多所以增添了很多东西；
语言不断升级：1添加新的功能，2修改问题；
ES6就是升级的版本，每年都有最新的版本，后面的力度不大，ES6是巨大的跨越程度最高；
未来10年什么样大家什么都不知道，但是5年之后开始就发现已经有人已经找不到工作了并且发现逐渐不能发展了，市场蛋糕变小了，所有领域包括前端5到10年发生什么谁也不知道；
大家好好学习的情况下，估计5到10年你也可能不再是只是学习某种语言的事情了，你最次也应该成为一个小组长；
JAVA的麻烦应该懂得是指什么，php也是一样的，js和python也是两种当前流行语言当中范围最广的，业务能够赚到钱才是发工资的基本，语言只是实现功能的工具，一定要保证好业务的实现；
出去找工作ES6肯定是潮流的，大家既然认为是有追求的，那么如果15~20年都没有更新实际上太守旧了；
新东西肯定会介绍给大家，介绍给大家但是并不一定有价值，流行不一定有价值，流行的书肯定有一部分是教你怎么成功的，“我的成功不可复制”肯定不会有人买的；
先不要急着反对，在辨别能力建立起来之前，也千万不要说怎么评价一个事物，老板和员工决定你怎么才能建立起来这个事情，“你竟然打我从小到大我妈都没打过我...”，因为你让他不开心他肯定会不喜欢你的，甚至以后在哪里在哪个地方不要指出对方的错误，你也不要认为程序员就会多么客观公正这也是一种工作而已；

新特性：
let限制var作用域在整个函数内部，只在花括号内部才有用，循环里面能够log外面不能log；
const变量的值声明之后不能赋值只能使用，不能出现在等号左边；
set的元素都是不重复的，是集合，add增加，has查找，seize大小，delete删除一个元素，交集、并集、补集都要自己实现；
我们通常把存储数据类型的东西叫做数据结构；
map用set增加一个值是一种映射关系跟object没什么区别，操作明显不是那么方便，用花括号建立，调用还是（“name”）；
数据结构和算法就是计算机内容的基础，我们不希望大家出来就是一个普通的程序员，但是肯定要掌握更多的知识和有效有用的知识，我们肯定是会教的；
我们从一个字符串得到另一个字符串要用到哈希表的结构，实现不了这个结构是不能够认为自己是“科班合格的”；
显著提升核心竞争力的内容就是那节课；



第二节

知乎林右；
有专门一节课讲爬虫，其实会引入一些写代码的东西，假设之前不会可能讲的说这些内容还是很快的；
总有人说你剑好不会夸你武功高的，其实只要是知识都是可以传授的，所有的内容都是可以传授的除非前置知识要求很多，对于计算机来说都是很简单的没有很难的知识都是很简单的；
人会倾向于相信一个东西是复杂的，相信一个事情是无害和简单的人都在进化中死掉了；
深度编程班里面很多内容一个学期的课程其实一节课就够了，不会很难要有人用正确的方式正确的教你才行，当你学会知识之后你就会有恍然大悟的感觉；
有的时候有些作者想故意让你看不懂，有的时候是作者也不是很明白，有的时候是有些人就是为了出书而出书，看有些人的书还不如学化妆；
数据结构、博客后端、用来防身自己可以再学一下内容；
...扩展符号，解开数组成为单独的元素，a1和...a1可以成为一个独特的元素来传参数；
解包，不给你引入额外变量如何交换两个变量的值，这个时候可以跟...连用，仅限于一层以内的嵌套不然读起来非常吃力；
...可变参数，放在参数列表里面就是可以让参数本身出现变化的内容，后面的值是给定的比如数组的内容；
箭头函数，=>是胖箭头，下面就是继续用到这个内容并且继续持续下去；
新增函数，includes这样的内容此外就不提了；
遍历对象的方式；
ES6遍历数组；

第三节
按照配置进行跟着配置；
谷歌推动了一个V8的引擎，属于比较好的车子用的，iPhone出来的时候是大屏幕电容屏低价，谷歌的浏览器是速度非常快执行js的意思就是用这种发动机；
语言快不快主要是看投入资源多少，后来觉得这么快还是很重要的，那么后来还是要看爹好不好还是很重要的，那么谷歌花了很多钱砸了这种东西而后就不再是一样的了，现在就是浏览器能够运用才形成的；
还是js的语法但是后面做了很多事情，当然最快的是c以后运行这个东西还是有自己的内容在的；
现在管理这些内容而后出现很多东西，并且可以运行之后，写程序就是需要一个语言的文档；
node的文档已经算很好的了，之后再继续解释就只能继续log一个东西出来，现在的require要引入一个模块，文件读写模块是Node的标准库；
（回调函数这里）不会在函数内执行，会在执行完之后才执行，跟读取时间先后有关；
现在要习惯使用箭头函数，必须要用显式判断方式；
删除文件和写入文件相关的内容；
异步：（JS的核心点）设计的时候为了放在浏览器里面运行操作是不能等着一行一行顺序执行的，浏览器明显会卡住，发明异步为了没有写完函数就结束了，立即被执行，但是写入的过程是后台去完成的，等到后台执行的任务完成后再去执行内部，js执行到多少行等到上面的行完成成功再进行执行，你并不是31行完成立刻32行，而是很多都进行执行，“多个步同时进行”；
0的意思是别的事情做完立即来做我这个事情；
不想让后面代码等的情况下，先执行的时候就要放到后面去执行的话不会卡住，所以就是重新执行上面里面的内容，一整个代码有自己内心的顺序，一整个代码是打包后面去执行不阻拦后面的去执行，同时也是有顺序的，同时的回调就会有“回调地域”但是现在这样的事情并不难理解；
sync就是同步的意思，就是等，等你一步一步地走才行；
不影响后面程序的执行就是很难看的，所以这个样子的，能理解多少算多少；


1、JS中的定时器有两种：
window.setTimeout([function],[interval]) 设置一个定时器,并且设定了一个等待的时间[interval],当到达时间后,执行对应的方法[function],当方法执行完成定时器停止(但是定时器还在,只不过没用了);

window.setInterval([function],[interval]) 设置一个定时器,并且设定了一个等待的时间[interval],当到达时间后,执行对应的方法[function],当方法执行完成,定时器并没有停止,以后每隔[interval]这么长的时间都会重新的执行对应的方法[function],直到我们手动清除定时器为止;

2、JS中的定时器是有返回值的:->返回值是一个数字,代表当前是第几个定时器

   var timer1=window.setTimeout(function(){},1000);  //timer1->1 当前是第一个定时器
   var timer2=window.setTimeout(function(){},1000);  //timer2->2 当前是第二个定时器
   window.clearTimeout(timer1); //->把第一个定时器清除掉,这里也可以用window.clearInterval(timer1)、window.clearTimeout(1)、window.clearInterval(timer1);
  var timer3=window.setTimeout(function(){},1000);   //timer3->3 当前是第三个定时器 ,虽然上面的定时器timer1清除掉了,但是号还是继续往后排的;
 
3、清除定时器：
window.clearInterval(timer1)/window.clearTimeout(time1)；两种清除方式都可以清除通过setTimeout和setInterval设置的定时器(两种方式在设置定时器的时候有区别，清除定时器的时候没有区别)，并且参数不仅可以是timer，还可以是其返回值，例如1,2；需要注意的是，定时器即使清除了，其返回值也不会清除，之后设置的定时器的返回值也会在其返回值的基础上继续向后排，这点类似于银行的排队领号，即使1号的业务办理完了，后边的人仍是从2号开始继续领号，而不是重新从1开始；






